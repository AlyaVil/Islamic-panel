// just a look at making islamic patterms
// first made by eye
// then created the points required using cossing points of the lines
// could use these points with laser cutter
// adjust the size with sliders

// plan
// save colours
// write out points for laser cutting
//
// nice to have
// graduated polygons, grad from a point, or use perlin noise

let box = 1
let boxLeft = 500
let boxTop = 20
let boxSize = 80
let boxes = 7
let sliders = 3
let sliderTop = 240
let sliderLeft = 1200
let sliderWidth = 30
let sliderHeight = 200
let M = []
let P = []
let S = [40,94,40]
let SIZE = [300,200,8]
let SMAX = [300,650,10]
let pTop = 400
let pLeft = 600
let pMax = 650
let z = 0

let palX = 30
let palY = 750
let palW = 70
let palH = 50
let palN = 0
let palMax = 12
let PAL
let RBOW

let SHOWLINES = false
let SHOWPOINTS = false
let drawLines = false

let WHEELDIAMETER = 300
let WHEELY = 650
let WHEELX = 1100
let WHEELLAYER = 40

function setup() {
	createCanvas(windowWidth, windowHeight)
	background(0,0,80);
	stroke(250)
	textSize(16);

	angleMode(DEGREES)
	makeByEye(160, 200, 15)
	makeByNumber(1050, 200, 10)
	
	// set default sizes
	for (let i=0; i<SIZE.length; i++) {
			SIZE[i] = (S[i]*SMAX[i] / 100)
	}
	
	PAL = []
	for (let i=0; i<palMax; i++) {
		PAL.push(color(random(255), random(255), random(255)))
	}
	
	setRainbow()
}

function draw() {
	drawBoxes(box)
	drawPalette(palN)
	drawSliders()
	drawColourWheel()
	angleMode(DEGREES)
	drawPattern()
}

function mousePressed() {
	if (pointInBox(mouseX,mouseY, boxLeft, boxTop,  boxes*boxSize, boxSize/2)) {
		box = int((mouseX - boxLeft)/boxSize)
		draw12(box)
	} else if (pointInBox(mouseX, mouseY, sliderLeft, sliderTop, sliders*sliderWidth, sliderHeight)) {
  	let slider = int((mouseX - sliderLeft) / sliderWidth)
		let percent = 100 - int((mouseY - sliderTop)*100/sliderHeight)
		S[slider] = percent
		for (let i=0; i<SIZE.length; i++) {
			SIZE[i] = floor(1 + (S[i]*SMAX[i] / 100))
		}
//		println(SIZE[2])
	} else if (pointInBox(mouseX, mouseY, sliderLeft+2*sliderWidth,sliderTop - 1.5*sliderWidth, sliderWidth, sliderWidth )) {
		drawLines = !drawLines
	} else if (pointInBox(mouseX, mouseY, palX, palY, palMax*(palW+4), palH)) {
		let choice = floor((mouseX - palX)/(palW + 4))
		palN = choice
	} else if (pointInBox(mouseX, mouseY, WHEELX-WHEELDIAMETER/2, WHEELY-WHEELDIAMETER/2, WHEELDIAMETER, WHEELDIAMETER)) {
		// probably on colour wheel
		let tan = (mouseY - WHEELY)/(mouseX - WHEELX)
		let angle = Math.atan(tan)
		if (tan < 0) {
			if (mouseX > WHEELX) {
				angle += 2*PI
			} else { 
				angle += PI
			}
		} else {
			if (mouseX < WHEELX) {
					angle += PI
			}
		}
		let n = floor(angle/(PI/6))
		// set colour
		let colr = RBOW[n]
		
		// set darkness/lightness
		let cent = sqrt(sq(mouseY - WHEELY) + sq(mouseX - WHEELX))
		n = floor((WHEELDIAMETER/2 - cent)/(WHEELLAYER/2))
		// println( cent + " " + n )
		if (n<2) {
			// lighten
			colr = shadeBlendConvert ( 0.3*(2-n), colr );
		} else if (n>2) {
			// darken
			colr = shadeBlendConvert ( -0.1*(n-2), colr );
		} 
		PAL[palN] = colr

	} else {
			
	}
}
function drawPattern() {
	fill(PAL[0])
	ellipse(pLeft, pTop, pMax, pMax)		// outer circle
	noStroke()
	fill(PAL[1])
	ellipse(pLeft, pTop, SIZE[1])
	
	makePoints(pLeft, pTop, SHOWPOINTS, SHOWLINES)
	drawFinalPolys(true, drawLines)
	drawMidPolys(true, drawLines)
	drawOuterPolys(true, drawLines)
	drawInnerPolys(true, drawLines)
}

// draw palette with one selected
function drawPalette (n) {
	push()
	strokeWeight(3)
	for (let i=0; i<palMax; i++) {
		noFill()
		if (i == n) {
			stroke('red')
		} else {
			stroke('white')
		}
		fill(PAL[i])
		rect(palX+i*(palW+4), palY, palW, palH, 20)
	}
	pop()
}

function setRainbow() {
	RBOW = []
	for (var i = 0; i < 12; i++) {
		if (i<2) {
			from = '#ff0000';
			to = '#ffff00';
			colr = shadeBlendConvert(i/2, from, to)
		} else if (i<4) {
			from = '#ffff00';
			to = '#00ff00';
			colr = shadeBlendConvert((i-2)/2, from, to)
		} else if (i<6) {
			from = '#00ff00';
			to = '#00ffff';
			colr = shadeBlendConvert((i-4)/2, from, to)
		} else if (i<8) {
			from = '#00ffff';
			to = '#0000ff';
			colr = shadeBlendConvert((i-6)/2, from, to)
		} else if (i<10) {
			from = '#0000ff';
			to = '#ff00ff';
			colr = shadeBlendConvert((i-8)/2, from, to)
		} else {
			from = '#ff00ff';
			to = '#ff0000';
			colr = shadeBlendConvert((i-10)/2, from, to)
		}
		RBOW.push(colr)
	}
}
